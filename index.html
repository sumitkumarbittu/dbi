<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Postgres File Injector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        html, body {
            overflow-x: hidden;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            border-radius: 25px;
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            color: white;
            font-weight: 600;
            margin-top: 15px;
            transition: all 0.3s ease;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #10b981;
            box-shadow: 0 0 10px #10b981;
        }

        .status-dot.disconnected {
            background: #ef4444;
            box-shadow: 0 0 10px #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="text"],
        input[type="url"],
        textarea {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }

        input[type="text"]:focus,
        input[type="url"]:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea {
            width: 100%;
            min-height: 150px;
            resize: vertical;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .btn-secondary:hover {
            background: #e5e7eb;
        }

        .btn-icon {
            padding: 10px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .info-box {
            background: #f9fafb;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .info-box label {
            font-size: 0.85rem;
            color: #6b7280;
            font-weight: 600;
            display: block;
            margin-bottom: 5px;
        }

        .info-box .value {
            font-family: 'Courier New', monospace;
            color: #1f2937;
            font-size: 0.9rem;
            word-break: break-all;
        }

        .upload-zone {
            border: 3px dashed #d1d5db;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #f9fafb;
        }

        .upload-zone:hover {
            border-color: #667eea;
            background: #f3f4f6;
        }

        .upload-zone.dragover {
            border-color: #667eea;
            background: #eef2ff;
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .file-info {
            margin-top: 15px;
            padding: 15px;
            background: #eef2ff;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            animation: slideIn 0.3s ease;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .notification.success {
            background: #10b981;
        }

        .notification.error {
            background: #ef4444;
        }

        .notification.info {
            background: #3b82f6;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .hidden {
            display: none;
        }

        .schema-section {
            margin-top: 15px;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .job-status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
        }

        .job-status.completed {
            background: #d1fae5;
            border-left-color: #10b981;
        }

        .job-status.failed {
            background: #fee2e2;
            border-left-color: #ef4444;
        }

        .spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .db-url-display {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: #f9fafb;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            color: #374151;
            word-break: break-all;
        }

        .api-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 15px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            border: 1px solid rgba(255,255,255,0.15);
        }

        .api-label {
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .api-boxes {
            display: flex;
            gap: 8px;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) transparent;
            padding: 2px 0;
            max-width: 100%;
        }

        .api-boxes::-webkit-scrollbar {
            height: 4px;
        }

        .api-boxes::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }

        .api-boxes::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        .api-boxes::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }

        .api-box {
            padding: 8px 50px;
            border-radius: 20px;
            background: rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.8);
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 120px;
            text-align: center;
            user-select: none;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .api-box:hover {
            background: rgba(255,255,255,0.25);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .api-box.selected {
            background: rgba(255,255,255,0.95);
            color: #667eea;
            box-shadow: 0 4px 16px rgba(255,255,255,0.4);
            font-weight: 700;
            transform: scale(1.05);
        }

        .pill {
            display: inline-flex;
            align-items: center;
            padding: 6px 10px;
            border-radius: 999px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            border: 1px solid #e5e7eb;
            background: #f9fafb;
            color: #374151;
            margin: 4px 6px 0 0;
        }

        .pill.match {
            border-color: #10b981;
            background: #d1fae5;
            color: #065f46;
        }

        .pill.mismatch {
            border-color: #ef4444;
            background: #fee2e2;
            color: #7f1d1d;
        }

        .mapping-section {
            margin-top: 16px;
            padding: 15px;
            border-radius: 12px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
        }

        .mapping-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            align-items: center;
            padding: 10px;
            border-radius: 10px;
            background: white;
            border: 1px solid #e5e7eb;
            margin-top: 10px;
        }

        .mapping-row label {
            margin: 0;
            font-size: 0.85rem;
            color: #6b7280;
            font-weight: 700;
        }

        select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            background: white;
            font-size: 0.95rem;
            font-family: 'Courier New', monospace;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .preview-card {
            margin-top: 12px;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            background: #ffffff;
        }

        .preview-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .preview-table th,
        .preview-table td {
            border-bottom: 1px solid #e5e7eb;
            padding: 8px 10px;
            text-align: left;
            vertical-align: top;
        }

        .preview-table th {
            background: #f9fafb;
            position: sticky;
            top: 0;
        }

        .preview-table tr {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .preview-table tr:hover {
            background-color: #f3f4f6;
        }

        .preview-table tr.selected {
            background-color: #eef2ff;
            border-left: 3px solid #667eea;
        }

        .preview-table tr.selected:hover {
            background-color: #e0e7ff;
        }

        .row-checkbox {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            cursor: pointer;
        }

        .selected-counter {
            color: #667eea;
            font-weight: 600;
        }

        .job-cards-container {
            margin-top: 20px;
            position: relative;
            padding-bottom: 10px;
        }

        .job-card {
            background: white;
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            animation: slideInUp 0.4s ease;
            will-change: transform;
        }

        .job-cards-container.stacked .job-card {
            position: absolute;
            left: 0;
            right: 0;
            margin-bottom: 0;
        }

        .job-card:hover {
            box-shadow: 0 14px 38px rgba(0,0,0,0.16);
        }

        .job-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .job-card-title {
            font-size: 1rem;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }

        .job-id-badge {
            align-self: flex-start;
        }

        .job-card-status {
            font-size: 0.85rem;
        }

        .job-progress-info {
            font-size: 0.8rem;
        }

        .job-details {
            font-size: 0.75rem;
            padding: 10px;
        }

        .job-error {
            font-size: 0.75rem;
            padding: 10px;
        }

        @media (max-width: 640px) {
            .input-wrapper {
                flex-direction: column;
                align-items: stretch;
            }

            .btn {
                width: 100%;
                justify-content: center;
            }

            .mapping-row {
                grid-template-columns: 1fr;
            }

            .file-info {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .db-url-display {
                flex-direction: column;
                align-items: stretch;
            }
        }

        @media (max-width: 768px) {
            .job-card {
                width: 100%;
                align-items: stretch;
                gap: 12px;
            }

            .db-url-display {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üêò Postgres File Injector</h1>
            <div class="status-badge" id="statusBadge">
                <div class="status-dot disconnected" id="statusDot"></div>
                <span id="statusText">Render: Disconnected</span>
            </div>
            
            <!-- API Selection -->
            <div class="api-selector" id="apiSelector">
                <div class="api-label">API Base:</div>
                <div class="api-boxes" id="apiBoxes"></div>
            </div>
        </div>

        <!-- Database Connection -->
        <div class="card">
            <div class="card-title">üîå Database Connection</div>
            <div class="input-group" id="dbUrlGroup">
                <label>PostgreSQL Connection URL</label>
                <div id="dbUrlDisplay" class="hidden">
                    <div class="db-url-display">
                        <span id="dbUrlText">Not configured</span>
                        <button class="btn btn-icon btn-secondary" onclick="editDbUrl()">‚úèÔ∏è</button>
                    </div>
                </div>
                <div class="input-wrapper" id="dbUrlInput">
                    <input type="text" id="dbUrl" placeholder="postgresql://user:password@host:port/database">
                    <button class="btn btn-primary" onclick="saveDbConnection()">üíæ Save</button>
                </div>
            </div>
        </div>

        <!-- Create Table -->
        <div class="card">
            <div class="card-title">
                üìã Table Management
                <button class="btn btn-secondary" style="margin-left: auto;" onclick="toggleCreateTable()">
                    <span id="createTableBtnText">‚ûï Create Table</span>
                </button>
            </div>
            
            <div class="schema-section hidden" id="schemaSection">
                <div class="input-group">
                    <label>SQL Schema</label>
                    <textarea id="createTableSql" placeholder="CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE
);"></textarea>
                </div>
                <button class="btn btn-primary" onclick="executeCreateTable()">‚ö° Execute</button>
            </div>
        </div>

        <!-- Table Schema Info -->
        <div class="card">
            <div class="card-title">üìä Table Schema</div>
            <div class="input-group">
                <label>Table Name</label>
                <div class="input-wrapper">
                    <input type="text" id="tableName" placeholder="users">
                    <button class="btn btn-primary" onclick="fetchTableSchema()">üîç Set</button>
                </div>
            </div>
            
            <div class="info-grid" id="schemaInfo" style="display: none;">
                <div class="info-box">
                    <label>Primary Key</label>
                    <div class="value" id="primaryKey">-</div>
                </div>
                <div class="info-box">
                    <label>Attributes</label>
                    <div class="value" id="attributes">-</div>
                </div>
            </div>
        </div>

        <!-- File Upload -->
        <div class="card hidden" id="uploadCard">
            <div class="card-title">üì§ Upload Data</div>
            
            <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
                <div class="upload-icon">üìÅ</div>
                <h3>Drop your file here or click to browse</h3>
                <p style="color: #6b7280; margin-top: 10px;">Supports CSV and JSON files</p>
            </div>
            
            <input type="file" id="fileInput" accept=".csv,.json" style="display: none;" onchange="handleFileSelect(event)">
            
            <div id="fileInfoSection" class="hidden">
                <div class="file-info">
                    <div>
                        <strong>Selected:</strong> <span id="fileName"></span>
                        <div style="color: #6b7280; font-size: 0.9rem; margin-top: 5px;">
                            <span id="fileSize"></span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button class="btn btn-secondary" onclick="verifyFile()">‚úÖ Verify</button>
                        <button class="btn btn-primary" onclick="uploadFile()">üöÄ Upload</button>
                    </div>
                </div>

                <div class="mapping-section hidden" id="mappingSection">
                    <div style="font-weight: 800; color: #1f2937;">Attribute Mapping</div>
                    <div style="color: #6b7280; font-size: 0.9rem; margin-top: 6px;">
                        Table attributes are fixed. Select the CSV column to map into each table attribute.
                    </div>
                    <div id="mappingRows"></div>
                </div>

                <div class="preview-card hidden" id="previewCard">
                    <div style="display:flex; align-items:center; justify-content: space-between; gap: 10px;">
                        <div>
                            <div style="font-weight: 800; color: #1f2937;" id="previewTitle">Preview</div>
                            <div style="color: #6b7280; font-size: 0.9rem; margin-top: 4px;">
                                Showing <span id="previewRange">1-10</span>
                                <span id="selectedCounter" class="selected-counter hidden">| <span id="selectedCount">0</span> rows selected</span>
                            </div>
                        </div>
                        <div style="display:flex; gap: 10px; flex-wrap: wrap; justify-content: flex-end;">
                            <button class="btn btn-secondary" id="previewToggleBtn" onclick="togglePreviewMode()">Matched</button>
                            <button class="btn btn-secondary" onclick="selectAllRows()">Select All</button>
                            <button class="btn btn-secondary" onclick="clearSelection()">Clear</button>
                            <button class="btn btn-secondary" onclick="previewPrev()">-10</button>
                            <button class="btn btn-secondary" onclick="previewNext()">+10</button>
                        </div>
                    </div>
                    <div style="max-height: 280px; overflow: auto; border-radius: 10px;">
                        <table class="preview-table" id="previewTable"></table>
                    </div>
                </div>
            </div>

            <div id="jobStatusSection" class="hidden"></div>
        </div>

        <!-- Job Cards Container -->
        <div id="jobCardsContainer" class="job-cards-container"></div>
    </div>

    <script>
        const API_CONFIGS = {
            'A': 'https://dbi.onrender.com',
            'B': 'https://dbi-2xer.onrender.com',
            'C': 'https://dbi2.onrender.com'
        };
        let selectedApi = 'B';
        let renderApiUrl = API_CONFIGS['B'];
        let currentDbUrl = '';
        let tableSchema = null;
        let selectedFile = null;
        let csvHeader = [];
        let csvRows = [];
        let jsonObjects = null;
        let previewOffset = 0;
        let columnMapping = {};
        let previewMode = 'matched'; // 'matched' | 'raw'
        let selectedRows = new Set(); // Store selected row indices
        let jobCardOrder = [];

        function escapeHtml(value) {
            return String(value)
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", '&#39;');
        }

        function isBufferLikeObject(v) {
            return v && typeof v === 'object' && v.type === 'Buffer' && Array.isArray(v.data);
        }

        function bufferObjectToBase64(v) {
            try {
                const bytes = new Uint8Array(v.data);
                let binary = '';
                const chunk = 0x8000;
                for (let i = 0; i < bytes.length; i += chunk) {
                    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
                }
                return btoa(binary);
            } catch {
                return null;
            }
        }

        function formatPreviewValue(v) {
            if (v === null || v === undefined) return '';
            if (typeof v === 'string') {
                const s = v;
                return s.length > 500 ? (s.slice(0, 500) + '‚Ä¶') : s;
            }
            if (typeof v === 'number' || typeof v === 'boolean') return String(v);
            if (isBufferLikeObject(v)) {
                const b64 = bufferObjectToBase64(v);
                if (b64) return `base64:${b64.length > 500 ? (b64.slice(0, 500) + '‚Ä¶') : b64}`;
            }
            if (typeof v === 'object') {
                try {
                    const s = JSON.stringify(v);
                    return s && s.length > 500 ? (s.slice(0, 500) + '‚Ä¶') : (s ?? '');
                } catch {
                    return '[unprintable]';
                }
            }
            return String(v);
        }

        // Check Render connection
        async function checkRenderConnection() {
            const selectedConfig = API_CONFIGS[selectedApi];
            renderApiUrl = selectedConfig;
            
            try {
                const res = await fetch(`${renderApiUrl}/health`);
                if (res.ok) {
                    updateStatus(true);
                } else {
                    updateStatus(false);
                }
            } catch (err) {
                updateStatus(false);
            }
        }

        function updateStatus(connected) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            
            if (connected) {
                dot.className = 'status-dot connected';
                text.textContent = 'Render: Connected';
            } else {
                dot.className = 'status-dot disconnected';
                text.textContent = 'Render: Disconnected';
            }
        }

        // Save DB connection
        async function saveDbConnection() {
            const url = document.getElementById('dbUrl').value.trim();
            if (!url) {
                showNotification('Please enter a database URL', 'error');
                return;
            }

            try {
                const res = await fetch(`${renderApiUrl}/save-db`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ database_url: url })
                });

                if (res.ok) {
                    currentDbUrl = url;
                    document.getElementById('dbUrlText').textContent = maskUrl(url);
                    document.getElementById('dbUrlDisplay').classList.remove('hidden');
                    document.getElementById('dbUrlInput').classList.add('hidden');
                    showNotification('Database connection saved!', 'success');
                } else {
                    showNotification('Failed to save connection', 'error');
                }
            } catch (err) {
                showNotification('Error: ' + err.message, 'error');
            }
        }

        function editDbUrl() {
            document.getElementById('dbUrlDisplay').classList.add('hidden');
            document.getElementById('dbUrlInput').classList.remove('hidden');
            document.getElementById('dbUrl').value = currentDbUrl;
        }

        function maskUrl(url) {
            try {
                const parsed = new URL(url);
                return `${parsed.protocol}//${parsed.username}:***@${parsed.host}${parsed.pathname}`;
            } catch {
                return url.substring(0, 30) + '...';
            }
        }

        // Toggle create table section
        function toggleCreateTable() {
            const section = document.getElementById('schemaSection');
            const btnText = document.getElementById('createTableBtnText');
            
            if (section.classList.contains('hidden')) {
                section.classList.remove('hidden');
                btnText.textContent = '‚úñÔ∏è Cancel';
            } else {
                section.classList.add('hidden');
                btnText.textContent = '‚ûï Create Table';
            }
        }

        // Execute create table
        async function executeCreateTable() {
            const sql = document.getElementById('createTableSql').value.trim();
            if (!sql) {
                showNotification('Please enter SQL schema', 'error');
                return;
            }

            try {
                const res = await fetch(`${renderApiUrl}/create-table`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ create_sql: sql })
                });

                const data = await res.json();
                
                if (res.ok) {
                    showNotification('Table created successfully!', 'success');
                    toggleCreateTable();
                    document.getElementById('createTableSql').value = '';
                } else {
                    showNotification('Error: ' + errorToString(data.detail), 'error');
                }
            } catch (err) {
                showNotification('Error: ' + err.message, 'error');
            }
        }

        // Fetch table schema
        async function fetchTableSchema() {
            const table = document.getElementById('tableName').value.trim();
            if (!table) {
                showNotification('Please enter a table name', 'error');
                return;
            }

            try {
                const res = await fetch(`${renderApiUrl}/table-schema?table=${table}`);
                const data = await res.json();
                
                if (res.ok) {
                    tableSchema = data;
                    document.getElementById('primaryKey').textContent = data.primary_key.join(', ') || 'None';
                    document.getElementById('attributes').textContent = data.attributes.join(', ');
                    document.getElementById('schemaInfo').style.display = 'grid';
                    document.getElementById('uploadCard').classList.remove('hidden');

                    selectedFile = null;
                    csvHeader = [];
                    csvRows = [];
                    previewOffset = 0;
                    columnMapping = {};
                    document.getElementById('fileInfoSection').classList.add('hidden');
                    document.getElementById('fileInput').value = '';
                    document.getElementById('jobStatusSection').classList.add('hidden');
                    document.getElementById('mappingSection').classList.add('hidden');
                    document.getElementById('previewCard').classList.add('hidden');
                    showNotification('Schema loaded!', 'success');
                } else {
                    tableSchema = null;
                    document.getElementById('schemaInfo').style.display = 'none';
                    document.getElementById('uploadCard').classList.add('hidden');
                    showNotification('Error: ' + errorToString(data.detail), 'error');
                }
            } catch (err) {
                tableSchema = null;
                document.getElementById('schemaInfo').style.display = 'none';
                document.getElementById('uploadCard').classList.add('hidden');
                showNotification('Error: ' + err.message, 'error');
            }
        }

        function parseCsvLine(line) {
            const out = [];
            let cur = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (inQuotes) {
                    if (ch === '"') {
                        if (line[i + 1] === '"') {
                            cur += '"';
                            i++;
                        } else {
                            inQuotes = false;
                        }
                    } else {
                        cur += ch;
                    }
                } else {
                    if (ch === ',') {
                        out.push(cur);
                        cur = '';
                    } else if (ch === '"') {
                        inQuotes = true;
                    } else {
                        cur += ch;
                    }
                }
            }
            out.push(cur);
            return out;
        }

        function csvEscape(value) {
            const v = value == null ? '' : String(value);
            if (v.includes('"') || v.includes(',') || v.includes('\n') || v.includes('\r')) {
                return '"' + v.replaceAll('"', '""') + '"';
            }
            return v;
        }

        function buildMappingUI() {
            const section = document.getElementById('mappingSection');
            const rowsEl = document.getElementById('mappingRows');
            rowsEl.innerHTML = '';

            if (!tableSchema || !Array.isArray(tableSchema.attributes) || tableSchema.attributes.length === 0) {
                section.classList.add('hidden');
                return;
            }

            if (!csvHeader || csvHeader.length === 0) {
                section.classList.add('hidden');
                return;
            }

            // Default mapping = same name if present, else keep empty
            const headerSet = new Set(csvHeader);
            for (const attr of tableSchema.attributes) {
                if (columnMapping[attr] === undefined) {
                    columnMapping[attr] = headerSet.has(attr) ? attr : '';
                }
            }

            for (const attr of tableSchema.attributes) {
                const mapped = columnMapping[attr] ?? '';
                const isMatch = mapped && mapped === attr;
                const isMapped = Boolean(mapped);

                const row = document.createElement('div');
                row.className = 'mapping-row';

                const left = document.createElement('div');
                left.innerHTML = `
                    <div style="display:flex; align-items:center; gap: 10px; flex-wrap: wrap;">
                        <span class="pill">${attr}</span>
                        <span class="pill ${isMapped ? (isMatch ? 'match' : 'mismatch') : 'mismatch'}">
                            ${isMapped ? mapped : 'keep empty'}
                        </span>
                    </div>
                    <div style="margin-top:6px;">
                        <label>Table attribute</label>
                    </div>
                `;

                const right = document.createElement('div');
                const select = document.createElement('select');
                select.dataset.tableAttr = attr;

                const optEmpty = document.createElement('option');
                optEmpty.value = '';
                optEmpty.textContent = 'keep empty';
                select.appendChild(optEmpty);

                const optAuto = document.createElement('option');
                optAuto.value = '__AUTO__';
                optAuto.textContent = 'auto-generate';
                select.appendChild(optAuto);

                for (const h of csvHeader) {
                    const opt = document.createElement('option');
                    opt.value = h;
                    opt.textContent = h;
                    select.appendChild(opt);
                }
                select.value = mapped;
                select.addEventListener('change', (e) => {
                    columnMapping[attr] = e.target.value;
                    buildMappingUI();
                });
                right.appendChild(select);

                row.appendChild(left);
                row.appendChild(right);
                rowsEl.appendChild(row);
            }

            section.classList.remove('hidden');
        }

        function setPreviewTitle() {
            const titleEl = document.getElementById('previewTitle');
            if (!titleEl) return;
            if (!selectedFile) {
                titleEl.textContent = 'Preview';
                return;
            }
            titleEl.textContent = selectedFile.name.toLowerCase().endsWith('.json') ? 'JSON Preview' : 'CSV Preview';
        }

        function getJsonKeySet(dataArr) {
            const keys = new Set();
            for (const row of dataArr) {
                if (row && typeof row === 'object' && !Array.isArray(row)) {
                    Object.keys(row).forEach(k => keys.add(k));
                }
            }
            return Array.from(keys);
        }

        function renderPreview() {
            const card = document.getElementById('previewCard');
            const table = document.getElementById('previewTable');

            if (!csvHeader || csvHeader.length === 0 || !csvRows) {
                card.classList.add('hidden');
                return;
            }

            const toggleBtn = document.getElementById('previewToggleBtn');
            if (toggleBtn) {
                toggleBtn.textContent = previewMode === 'raw' ? 'CSV' : 'Matched';
            }

            const start = previewOffset;
            const end = Math.min(previewOffset + 10, csvRows.length);
            document.getElementById('previewRange').textContent = `${start + 1}-${end}`;

            if (previewMode === 'raw') {
                const headerHtml = `<tr><th style="width: 30px;"><input type="checkbox" class="row-checkbox" onchange="toggleSelectAll()"></th>${csvHeader.map(h => `<th>${h}</th>`).join('')}</tr>`;
                const bodyHtml = csvRows.slice(start, end).map((r, rowIdx) => {
                    const globalIdx = start + rowIdx;
                    const isSelected = selectedRows.has(globalIdx);
                    return `<tr class="${isSelected ? 'selected' : ''}" onclick="toggleRowSelection(${globalIdx})">
                        <td><input type="checkbox" class="row-checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleRowSelection(${globalIdx})"></td>
                        ${csvHeader.map((_, idx) => `<td>${escapeHtml(formatPreviewValue(r[idx]))}</td>`).join('')}
                    </tr>`;
                }).join('');
                table.innerHTML = `<thead>${headerHtml}</thead><tbody>${bodyHtml}</tbody>`;
                updateSelectedCounter();
                card.classList.remove('hidden');
                return;
            }

            // matched/mapped preview
            if (!tableSchema || !Array.isArray(tableSchema.attributes) || tableSchema.attributes.length === 0) {
                card.classList.add('hidden');
                return;
            }

            const mappedTableAttrs = tableSchema.attributes.filter(a => {
                const m = columnMapping[a];
                return m && m !== '' && m !== '__AUTO__';
            });

            if (mappedTableAttrs.length === 0) {
                card.classList.add('hidden');
                return;
            }

            const idxByCsv = {};
            csvHeader.forEach((h, i) => { idxByCsv[h] = i; });

            const headerHtml = `<tr><th style="width: 30px;"><input type="checkbox" class="row-checkbox" onchange="toggleSelectAll()"></th>${mappedTableAttrs.map(h => `<th>${h}</th>`).join('')}</tr>`;
            const bodyHtml = csvRows.slice(start, end).map((r, rowIdx) => {
                const globalIdx = start + rowIdx;
                const isSelected = selectedRows.has(globalIdx);
                return `<tr class="${isSelected ? 'selected' : ''}" onclick="toggleRowSelection(${globalIdx})">
                    <td><input type="checkbox" class="row-checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleRowSelection(${globalIdx})"></td>
                    ${mappedTableAttrs.map((attr) => {
                        const mapped = columnMapping[attr];
                        const idx = idxByCsv[mapped];
                        return `<td>${escapeHtml(formatPreviewValue(idx === undefined ? '' : (r[idx] ?? '')))}</td>`;
                    }).join('')}
                </tr>`;
            }).join('');

            table.innerHTML = `<thead>${headerHtml}</thead><tbody>${bodyHtml}</tbody>`;
            updateSelectedCounter();
            card.classList.remove('hidden');
        }

        function togglePreviewMode() {
            previewMode = previewMode === 'raw' ? 'matched' : 'raw';
            renderPreview();
        }

        // Row selection functions
        function toggleRowSelection(rowIndex) {
            if (selectedRows.has(rowIndex)) {
                selectedRows.delete(rowIndex);
            } else {
                selectedRows.add(rowIndex);
            }
            renderPreview();
        }

        function toggleSelectAll() {
            const start = previewOffset;
            const end = Math.min(previewOffset + 10, csvRows.length);
            const allSelected = Array.from({length: end - start}, (_, i) => start + i).every(i => selectedRows.has(i));
            
            if (allSelected) {
                // Deselect all in current view
                for (let i = start; i < end; i++) {
                    selectedRows.delete(i);
                }
            } else {
                // Select all in current view
                for (let i = start; i < end; i++) {
                    selectedRows.add(i);
                }
            }
            renderPreview();
        }

        function selectAllRows() {
            for (let i = 0; i < csvRows.length; i++) {
                selectedRows.add(i);
            }
            renderPreview();
        }

        function clearSelection() {
            selectedRows.clear();
            renderPreview();
        }

        function updateSelectedCounter() {
            const counter = document.getElementById('selectedCounter');
            const count = document.getElementById('selectedCount');
            
            if (selectedRows.size > 0) {
                counter.classList.remove('hidden');
                count.textContent = selectedRows.size;
            } else {
                counter.classList.add('hidden');
            }
        }

        function previewNext() {
            if (!csvRows || csvRows.length === 0) return;
            previewOffset = Math.min(previewOffset + 10, Math.max(csvRows.length - 1, 0));
            renderPreview();
        }

        function previewPrev() {
            if (!csvRows || csvRows.length === 0) return;
            previewOffset = Math.max(previewOffset - 10, 0);
            renderPreview();
        }

        async function verifyFile() {
            if (!selectedFile) {
                showNotification('No file selected', 'error');
                return;
            }
            if (!tableSchema) {
                showNotification('Please set table schema first', 'error');
                return;
            }

            try {
                setPreviewTitle();

                if (selectedFile.name.toLowerCase().endsWith('.csv')) {
                    const text = await selectedFile.text();
                    const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n').filter(l => l.length > 0);
                    if (lines.length === 0) {
                        showNotification('CSV file is empty', 'error');
                        return;
                    }
                    csvHeader = parseCsvLine(lines[0]).map(s => s.trim()).filter(Boolean);
                    csvRows = lines.slice(1).map(parseCsvLine);
                    jsonObjects = null;
                } else if (selectedFile.name.toLowerCase().endsWith('.json')) {
                    const text = await selectedFile.text();
                    let parsed;
                    try {
                        parsed = JSON.parse(text);
                    } catch {
                        showNotification('Invalid JSON: could not parse file', 'error');
                        return;
                    }

                    const arr = Array.isArray(parsed) ? parsed : [parsed];
                    const objs = arr.filter(x => x && typeof x === 'object' && !Array.isArray(x));
                    if (objs.length === 0) {
                        showNotification('JSON must be an object or an array of objects', 'error');
                        return;
                    }

                    jsonObjects = objs;
                    csvHeader = getJsonKeySet(objs);
                    if (!csvHeader || csvHeader.length === 0) {
                        showNotification('JSON has no keys to preview', 'error');
                        return;
                    }
                    csvRows = objs.map(o => csvHeader.map(k => (o?.[k] ?? '')));
                } else {
                    showNotification('Only CSV and JSON files are supported', 'error');
                    return;
                }

                previewOffset = 0;
                previewMode = 'matched';
                selectedRows.clear();

                buildMappingUI();
                renderPreview();
                showNotification((selectedFile.name.toLowerCase().endsWith('.json') ? 'JSON' : 'CSV') + ' verified!', 'success');
            } catch (err) {
                showNotification('Verify error: ' + err.message, 'error');
            }
        }

        // File handling
        const uploadZone = document.getElementById('uploadZone');
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });
        
        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });
        
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                handleFile(file);
            }
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        function handleFile(file) {
            if (!file.name.endsWith('.csv') && !file.name.endsWith('.json')) {
                showNotification('Only CSV and JSON files are supported', 'error');
                return;
            }

            selectedFile = file;
            csvHeader = [];
            csvRows = [];
            jsonObjects = null;
            previewOffset = 0;
            columnMapping = {};
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatBytes(file.size);
            document.getElementById('fileInfoSection').classList.remove('hidden');
            document.getElementById('mappingSection').classList.add('hidden');
            document.getElementById('previewCard').classList.add('hidden');
            setPreviewTitle();
        }

        async function uploadFile() {
            if (!selectedFile) {
                showNotification('No file selected', 'error');
                return;
            }

            if (!tableSchema) {
                showNotification('Please set table schema first', 'error');
                return;
            }

            if (!renderApiUrl) {
                showNotification('Please set Render API URL first', 'error');
                return;
            }

            if (!Array.isArray(tableSchema.attributes) || tableSchema.attributes.length === 0) {
                showNotification('Table attributes not loaded', 'error');
                return;
            }

            if (!Array.isArray(tableSchema.primary_key) || tableSchema.primary_key.length === 0) {
                showNotification('Table primary key not loaded', 'error');
                return;
            }

            // For CSV, require verify + mapping
            if (!csvHeader || csvHeader.length === 0) {
                showNotification('Click Verify to load preview and mapping first', 'error');
                return;
            }

            const isCsv = selectedFile.name.toLowerCase().endsWith('.csv');
            const isJson = selectedFile.name.toLowerCase().endsWith('.json');

            // PK can be auto-generated. If user maps PK, keep it; otherwise we'll omit it and send empty primary_key.
            const includedTableAttrs = tableSchema.attributes.filter(a => columnMapping[a] && columnMapping[a] !== '__AUTO__');
            if (includedTableAttrs.length === 0) {
                showNotification('Please map at least one attribute (or use Raw preview)', 'error');
                return;
            }

            if (isCsv) {
                const outHeader = includedTableAttrs;
                const idxByCsv = {};
                csvHeader.forEach((h, i) => { idxByCsv[h] = i; });

                const outLines = [];
                outLines.push(outHeader.map(csvEscape).join(','));

                const rowsToProcess = selectedRows.size > 0
                    ? Array.from(selectedRows).sort((a, b) => a - b).map(i => csvRows[i])
                    : csvRows;

                for (const row of rowsToProcess) {
                    const outRow = outHeader.map(attr => {
                        const mapped = columnMapping[attr];
                        const idx = idxByCsv[mapped];
                        return csvEscape(idx === undefined ? '' : (row[idx] ?? ''));
                    });
                    outLines.push(outRow.join(','));
                }

                const blob = new Blob([outLines.join('\n')], { type: 'text/csv' });
                selectedFile = new File([blob], selectedFile.name, { type: 'text/csv' });
            }

            if (isJson) {
                if (!jsonObjects || !Array.isArray(jsonObjects) || jsonObjects.length === 0) {
                    showNotification('JSON not verified. Click Verify first', 'error');
                    return;
                }

                const rowsToProcess = selectedRows.size > 0
                    ? Array.from(selectedRows).sort((a, b) => a - b).map(i => jsonObjects[i]).filter(Boolean)
                    : jsonObjects;

                const outObjects = rowsToProcess.map((obj) => {
                    const out = {};
                    for (const attr of includedTableAttrs) {
                        const mapped = columnMapping[attr];
                        if (!mapped || mapped === '__AUTO__') continue;
                        const rawVal = obj?.[mapped];
                        if (rawVal === null || rawVal === undefined) {
                            out[attr] = '';
                        } else if (typeof rawVal === 'object') {
                            if (isBufferLikeObject(rawVal)) {
                                const b64 = bufferObjectToBase64(rawVal);
                                out[attr] = b64 ? b64 : JSON.stringify(rawVal);
                            } else {
                                out[attr] = JSON.stringify(rawVal);
                            }
                        } else {
                            out[attr] = rawVal;
                        }
                    }
                    return out;
                });

                const blob = new Blob([JSON.stringify(outObjects)], { type: 'application/json' });
                selectedFile = new File([blob], selectedFile.name, { type: 'application/json' });
            }

            const formData = new FormData();
            formData.append('file', selectedFile);
            formData.append('table', tableSchema.table);
            formData.append('columns', includedTableAttrs.join(','));

            const mappedPk = (tableSchema.primary_key || []).filter(pk => columnMapping[pk] && columnMapping[pk] !== '__AUTO__');
            formData.append('primary_key', mappedPk.join(','));

            try {
                const res = await fetch(`${renderApiUrl}/upload-data`, {
                    method: 'POST',
                    body: formData
                });

                const data = await res.json();
                
                if (res.ok) {
                    showNotification('Upload started!', 'info');
                    createJobCard(data.job_id, selectedFile.name);
                    monitorJobCard(data.job_id);
                } else {
                    showNotification('Error: ' + errorToString(data.detail), 'error');
                }
            } catch (err) {
                showNotification('Error: ' + err.message, 'error');
            }
        }

        // Create job card
        function createJobCard(jobId, fileName) {
            const container = document.getElementById('jobCardsContainer');
            
            const jobCard = document.createElement('div');
            jobCard.className = 'job-card';
            jobCard.id = `job-card-${jobId}`;
            
            jobCard.innerHTML = `
                <div class="job-card-header">
                    <div class="job-card-title">
                        üì§ ${fileName}
                        <span class="job-id-badge">ID: ${jobId}</span>
                    </div>
                    <div class="job-card-status job-status-processing">
                        <div class="spinner"></div>
                        Processing...
                    </div>
                </div>
                <div class="job-progress-section">
                    <div class="job-progress-info">
                        <span>Upload Progress</span>
                        <span id="job-progress-${jobId}">0%</span>
                    </div>
                    <div class="job-progress-bar">
                        <div class="job-progress-fill" id="job-progress-bar-${jobId}" style="width: 0%"></div>
                    </div>
                </div>
                <div class="job-details" id="job-details-${jobId}">
                    Started: ${new Date().toLocaleString()} | API: ${selectedApi}
                </div>
            `;

            // Newest card should be on top of the stack
            container.insertBefore(jobCard, container.firstChild);
            jobCardOrder = [jobId, ...jobCardOrder.filter(id => id !== jobId)];
            updateJobCardStack();
        }

        function updateJobCardStack() {
            const container = document.getElementById('jobCardsContainer');
            const isStacked = window.innerWidth > 640;
            container.classList.toggle('stacked', isStacked);

            const cards = jobCardOrder
                .map(id => document.getElementById(`job-card-${id}`))
                .filter(Boolean);

            if (!isStacked) {
                container.style.minHeight = '0px';
                cards.forEach((card, i) => {
                    card.style.zIndex = '';
                    card.style.transform = '';
                    card.style.position = 'relative';
                    card.style.marginBottom = '12px';
                });
                return;
            }

            const offsetY = 12;
            const scaleStep = 0.018;

            const topCard = cards[0];
            const baseHeight = topCard ? topCard.getBoundingClientRect().height : 0;
            const minHeight = baseHeight ? (baseHeight + Math.min(cards.length - 1, 7) * offsetY + 16) : 0;
            container.style.minHeight = minHeight ? `${Math.max(minHeight, 140)}px` : '0px';

            cards.forEach((card, i) => {
                const clamped = Math.min(i, 7);
                const translateY = clamped * offsetY;
                const scale = 1 - clamped * scaleStep;
                card.style.position = 'absolute';
                card.style.marginBottom = '0';
                card.style.zIndex = String(1000 - i);
                card.style.transform = `translateY(${translateY}px) scale(${scale})`;
            });
        }

        window.addEventListener('resize', () => {
            updateJobCardStack();
        });

        // Monitor job with card updates
        async function monitorJobCard(jobId) {
            const interval = setInterval(async () => {
                try {
                    const res = await fetch(`${renderApiUrl}/job-status/${jobId}`);
                    const job = await res.json();

                    const card = document.getElementById(`job-card-${jobId}`);
                    if (!card) {
                        clearInterval(interval);
                        return;
                    }

                    const statusEl = card.querySelector('.job-card-status');
                    const progressEl = document.getElementById(`job-progress-${jobId}`);
                    const progressBarEl = document.getElementById(`job-progress-bar-${jobId}`);
                    const detailsEl = document.getElementById(`job-details-${jobId}`);

                    if (job.status === 'completed') {
                        clearInterval(interval);
                        statusEl.className = 'job-card-status job-status-completed';
                        statusEl.innerHTML = '‚úÖ Completed';
                        progressEl.textContent = '100%';
                        progressBarEl.style.width = '100%';
                        detailsEl.innerHTML = `
                            Completed: ${new Date().toLocaleString()} | 
                            Total rows: ${job.rows_total} | 
                            Inserted: ${job.rows_inserted} | 
                            Skipped: ${job.rows_skipped} | 
                            API: ${selectedApi}
                        `;
                        showNotification('File uploaded successfully!', 'success');
                    } else if (job.status === 'failed') {
                        clearInterval(interval);
                        statusEl.className = 'job-card-status job-status-failed';
                        statusEl.innerHTML = '‚ùå Failed';
                        progressEl.textContent = '0%';
                        progressBarEl.style.width = '0%';
                        
                        // Add error section
                        const errorSection = document.createElement('div');
                        errorSection.className = 'job-error';
                        errorSection.textContent = job.error || 'Unknown error occurred';
                        card.appendChild(errorSection);
                        
                        detailsEl.innerHTML = `
                            Failed: ${new Date().toLocaleString()} | 
                            API: ${selectedApi}
                        `;
                        showNotification('Upload failed', 'error');
                    } else if (job.status === 'processing') {
                        // Update progress if available
                        const progress = job.progress || 0;
                        progressEl.textContent = `${progress}%`;
                        progressBarEl.style.width = `${progress}%`;
                        
                        if (job.rows_processed !== undefined) {
                            detailsEl.innerHTML = `
                                Processing... | 
                                Rows processed: ${job.rows_processed} | 
                                API: ${selectedApi}
                            `;
                        }
                    }
                } catch (err) {
                    clearInterval(interval);
                    const card = document.getElementById(`job-card-${jobId}`);
                    if (card) {
                        const statusEl = card.querySelector('.job-card-status');
                        const detailsEl = document.getElementById(`job-details-${jobId}`);
                        statusEl.className = 'job-card-status job-status-failed';
                        statusEl.innerHTML = '‚ùå Connection Error';
                        detailsEl.innerHTML = `
                            Error: Could not check job status | 
                            API: ${selectedApi}
                        `;
                    }
                    showNotification('Error checking job status', 'error');
                }
            }, 2000);
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Initialize API selector
        function initializeApiSelector() {
            const container = document.getElementById('apiBoxes');
            container.innerHTML = '';
            
            Object.keys(API_CONFIGS).forEach(key => {
                const box = document.createElement('div');
                box.className = `api-box ${key === selectedApi ? 'selected' : ''}`;
                box.textContent = key;
                box.onclick = () => selectApi(key, box);
                container.appendChild(box);
            });
        }
        
        function selectApi(key, el) {
            selectedApi = key;
            renderApiUrl = API_CONFIGS[key];
            document.querySelectorAll('.api-box').forEach(box => {
                box.classList.remove('selected');
            });
            if (el) {
                el.classList.add('selected');
            }
            
            // Update the display text
            document.getElementById('renderUrlText').textContent = API_CONFIGS[key];
            
            checkRenderConnection();
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            // Always reset to B on reload
            selectedApi = 'B';
            renderApiUrl = API_CONFIGS[selectedApi];
            initializeApiSelector();
            const urlText = document.getElementById('renderUrlText');
            if (urlText) urlText.textContent = API_CONFIGS[selectedApi];
            checkRenderConnection();
        });

        function errorToString(detail) {
        if (typeof detail === 'string') return detail;
        if (detail?.error) return detail.error;
        return JSON.stringify(detail);
        }
    </script>
    <script src="track.js"></script>
</body>
</html>